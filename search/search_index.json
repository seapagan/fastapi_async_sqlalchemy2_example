{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Async SQLAlchemy 2 with FastAPI","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This repository contains a very simple example how to use FastAPI with Async SQLAlchemy 2.0, in <code>ORM</code> mode. I'll probably add an example for <code>Core</code> mode also. No effort has been made to make this a production ready application, it's just a simple demo since at the time of writing there were few clear examples of how to do this.</p> <p>Last update 29th January 2024, and tested to work with the following versions:</p> <ul> <li>Python 3.9+</li> <li>FastAPI 0.109.0</li> <li>SQLAlchemy  2.0.25</li> </ul>"},{"location":"#why-use-raw-sqlalchemy","title":"Why use Raw SQLAlchemy?","text":"<p>I was using FastAPI and SQLAlchemy combined with encode/databases for a while. This worked fine originally but I felt I needed a bit more control over the database session management.</p> <p>Info</p> <p>The databases package is a great wrapper around <code>SQLAlchemy</code> that allows you to use async/await for database operations. It also has a nice way of managing the database session, which is why I used it originally.</p> <p>However, this did not seem be be actively maintained at the time, so I decided to give the newer Async SQLAlchemy a try instead.</p> <p>This repository is the result of my exprimentation while converting my FastAPI-template project to use <code>Async SQLAlchemy</code> instead of <code>databases</code>.</p>"},{"location":"license/","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p> <pre><code>MIT License\n\nCopyright (c) 2023-2025 Grant Ramsay\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"usage/","title":"Using this example","text":""},{"location":"usage/#installation","title":"Installation","text":"<p>Clone this repository and install the dependencies. This project uses uv for dependency management which should be installed on your system first.</p> <p>Install the dependencies:</p> <pre><code>uv sync\n</code></pre> <p>Then switch to the virtual environment:</p> <pre><code># On Linux:\nsource .venv/bin/activate\n\n# On Windows:\n.venv\\Scripts\\activate\n</code></pre>"},{"location":"usage/#usage","title":"Usage","text":"<p>Run the server using <code>Uvicorn</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Note</p> <p>You can also run the server by just executing the <code>main.py</code> file:</p> <pre><code>python main.py\n</code></pre> <p>or using the included <code>POE</code> alias:</p> <pre><code>poe serve\n</code></pre> <p>Then open your browser at http://localhost:8000.</p> <p>There is only one endpoint available: <code>/users</code>. It returns a list of all users for a <code>GET</code> request and creates a new user for a <code>POST</code> request.</p>"},{"location":"usage/#local-postgres-server-using-docker","title":"Local Postgres server using Docker","text":"<p>This example uses PostgreSQL as the database. If you dont have a local PostgreSQL database running, you can start one with Docker using the following command:</p> <pre><code>docker run \\\n  --rm   \\\n  --name  postgres \\\n  -p 5432:5432 \\\n  -e POSTGRES_USER=postgres \\\n  -e POSTGRES_PASSWORD=postgres \\\n  -e POSTGRES_DB=postgres \\\n  -d postgres\n</code></pre> <p>This will run a PostgreSQL database in a Docker container in the background. When you are finished and want to stop the database, run:</p> <pre><code>docker stop postgres\n</code></pre> <p>If needed, you can connect to the database managment by :</p> <pre><code>docker exec -it postgres psql -U postgres\n</code></pre> <p>This will allow you to edit or delete the database or records.</p>"},{"location":"usage/#use-sqlite-instead-of-postgresql","title":"Use SQLite instead of PostgreSQL","text":"<p>For testing purposes, you can also use SQLite instead of PostgreSQL. To do so, open the <code>db.py</code> file and comment out the PostgreSQL database in the <code>DATABASE_URL</code> environment variable and uncomment the SQLite database.</p> <pre><code># DATABASE_URL = \"postgresql+asyncpg://postgres:postgres@localhost/postgres\"\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\n</code></pre>"},{"location":"explanation/database/","title":"The Database file (db.py)","text":"<p>The database setup is fairly straightforward, we will go through it line by line.</p>"},{"location":"explanation/database/#imports","title":"Imports","text":"<pre><code>\"\"\"Set up the database connection and session.\"\"\" \"\"\nfrom collections.abc import AsyncGenerator\nfrom typing import Any\n\nfrom sqlalchemy import MetaData\nfrom sqlalchemy.ext.asyncio import (\n    AsyncSession,\n    async_sessionmaker,\n    create_async_engine,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n</code></pre> <p>Lines 1 to 11 are the imports. The only thing to note here is that we are using the <code>AsyncGenerator</code> type hint for the <code>get_db</code> function. This is because we are using the <code>yield</code> keyword in the function, which makes it a generator. The <code>AsyncGenerator</code> type hint is a special type hint that is used for asynchronous generators.</p>"},{"location":"explanation/database/#database-connection-string","title":"Database Connection String","text":"<pre><code>DATABASE_URL = \"postgresql+asyncpg://postgres:postgres@localhost/postgres\"\n# DATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\n</code></pre> <p>We set a variable to be used later which contains the database URL. We are using PostgreSQL, but you can use any database that SQLAlchemy supports. The commented out line is for SQLite, which is a good choice for testing. You can comment out the PostgreSQL line (13) and uncomment the SQLite line (14) to use SQLite instead.</p> <p>This is a basic connection string, in reality you would want to use environment variables to store the user/password and database name.</p>"},{"location":"explanation/database/#the-base-class","title":"The Base Class","text":"<pre><code>class Base(DeclarativeBase):\n    \"\"\"Base class for SQLAlchemy models.\n\n    All other models should inherit from this class.\n    \"\"\"\n\n    metadata = MetaData(\n        naming_convention={\n            \"ix\": \"ix_%(column_0_label)s\",\n            \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n            \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n            \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n            \"pk\": \"pk_%(table_name)s\",\n        }\n    )\n</code></pre> <p>This takes the <code>DeclarativeBase</code> class from SQLAlchemy and adds a <code>metadata</code> attribute to it. This is used to define the naming convention for the database tables. This is not required, but it is a good idea to set this up for consistency.</p> <p>We will use this class as the base class for all of our future models.</p>"},{"location":"explanation/database/#the-database-engine-and-session","title":"The database engine and session","text":"<pre><code>async_engine = create_async_engine(DATABASE_URL, echo=False)\n</code></pre> <p>Here on line 37 we create the database engine. The <code>create_async_engine</code> function takes the database URL and returns an engine, the connection to the database. The <code>echo</code> parameter is set to <code>False</code> to prevent SQLAlchemy from outputting all of the SQL commands it is running. Note that it uses the <code>DATABASE_URL</code> variable we set earlier.</p> <pre><code>async_session = async_sessionmaker(async_engine, expire_on_commit=False)\n</code></pre> <p>Next, we create the session. The <code>async_sessionmaker</code> function takes the engine and returns a session. The <code>expire_on_commit</code> parameter is set to <code>False</code> to prevent SQLAlchemy from expiring objects on commit. This is required for <code>asyncpg</code> to work properly.</p> <p>We will NOT use this session directly, instead we will use the <code>get_db</code> function below to get and release a session.</p>"},{"location":"explanation/database/#the-get_db-function","title":"The <code>get_db()</code> function","text":"<pre><code>async def get_db() -&gt; AsyncGenerator[AsyncSession, Any]:\n    \"\"\"Get a database session.\n\n    To be used for dependency injection.\n    \"\"\"\n    async with async_session() as session, session.begin():\n        yield session\n</code></pre> <p>This function is used to get a database session as a generator function. This function is used for dependency injection, which is a fancy way of saying that we will use it to pass the database session to other functions. Since we have used the <code>with</code> statement, the session will be automatically closed (and data comitted) when the function returns, usually after the related route is complete.</p> <p>Note</p> <p>Note that in line 46 we are using a combined <code>with</code> statement. This is a shortcut for using two nested <code>with</code> statements, one for the <code>async_session</code> and one for the <code>session.begin()</code>.</p>"},{"location":"explanation/database/#the-init_models-function","title":"The <code>init_models()</code> function","text":"<p>This function is used to create the database tables. It is called by the <code>lifespan()</code> function at startup.</p> <p>Note</p> <p>This function is only used in our demo, in a real application you would use a migration tool like Alembic instead.</p> <pre><code>async def init_models() -&gt; None:\n    \"\"\"Create tables if they don't already exist.\n\n    In a real-life example we would use Alembic to manage migrations.\n    \"\"\"\n    async with async_engine.begin() as conn:\n        # await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n</code></pre> <p>This function shows how to run a <code>syncronous</code> function in an <code>async</code> context using the <code>async_engine</code> object directly instead of the <code>async_session</code> object. On line 57 we use the <code>run_sync</code> method to run the <code>create_all</code> method of the <code>Base.metadata</code> object (a syncronous function). This will create all of the tables defined in the models.</p> <p>If you want to drop the tables and recreate them every time the server restarts, you can uncomment line 56. This is obviously not much good for production use, but it can be useful for testing.</p> <p>Next, we will look at the models themselves and the Schemas used to validate them within FastAPI.</p>"},{"location":"explanation/intro/","title":"Introduction","text":"<p>This section will attempt to explain the code in this repository. It is not meant to be a tutorial on how to use FastAPI or SQLAlchemy, but rather an explanation of how to get the two to work together Asynchronously.</p>"},{"location":"explanation/intro/#caveats","title":"Caveats","text":"<p>This is a very simple example of a REST API. It is not meant to be used in production, it is meant to be a simple example of how to use FastAPI and SQLAlchemy together Asynchronously. As such there are some things that you would not do in a production environment, such as:</p> <ul> <li>Using SQLite as the database</li> <li>Manual database migrations, instead of using a tool like Alembic</li> <li>No validation of the data being sent to the API</li> <li>No check for duplicate email addresses</li> <li>The code layout is not optimal. The relevant files are all in the root   directory, instead of being in a <code>src</code> directory or similar, and the routes   would be better in a separate file.</li> </ul> <p>The above is not an exhaustive list!</p>"},{"location":"explanation/intro/#relevant-files","title":"Relevant Files","text":"<ul> <li><code>main.py</code> - The main file that runs the program and contains the routes</li> <li><code>db.py</code> - This file contains the database connection and functions</li> <li><code>models.py</code> - This file contains the database models</li> <li><code>schema.py</code> - This defines the Pydantic schemas for the models, used for   validation and serialization.</li> </ul>"},{"location":"explanation/main/","title":"The Main Application and Routes","text":"<p>To be Added</p> <p>This section is not yet written.</p>"},{"location":"explanation/models/","title":"Models and Schemas","text":"<p>To be Added</p> <p>This section is not yet written.</p>"}]}